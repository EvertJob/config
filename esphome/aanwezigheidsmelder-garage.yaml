substitutions:
# Change the disp_name to something you want  
  display_name: Aanwezigbeidsmelder garage
# Interval of how often the power is updated
  update_time: 1s
  
# Please rename device and friendly name
  device_name: "aanwezigheidsmelder-garage"
  friendly_name: "Aanwezigheidsmelder Garage"
  project_name: "Toppe.Aanwezigheidsmelder"
  project_version: "1.0"
  
esphome:
  name: "${device_name}"
  project:
    name: "${project_name}"
    version: "${project_version}"
  comment: ${display_name}
  includes:
    - uart_read_radar_sensor.h
  libraries:
    - "Seeed Arduino 24GHz Radar Sensor"

esp8266:
  board: esp01_1m
    
web_server:
  port: 80
  version: 3

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password
  fast_connect: true
#  power_save_mode: none

# Enable logging
logger:
  level: INFO #makes uart stream available in esphome logstream
  baud_rate: 0

# Enable Home Assistant API
api:
  services:
      # Service to send a command directly to the display. Useful for testing
    - service: send_command
      variables:
        cmd: string
      then:
        - uart.write: !lambda
                        char buf[128];
                        sprintf(buf, "%s\n", cmd.c_str());
                        std::string s = buf;
                        return std::vector<unsigned char>( s.begin(), s.end() );

ota:
  - platform: esphome
    password: "s"

uart:
  id: uart_bus
  tx_pin: GPIO1
  rx_pin: GPIO3
  baud_rate: 9600
#  debug:

# Example configuration entry
binary_sensor:
  - platform: gpio
    pin: GPIO16
    name: ${display_name} Presence
    device_class: motion
    filters:
      - delayed_on: 100ms
      - delayed_off: 500ms
  - platform: gpio
    pin: GPIO5
    name: ${display_name} Moving
    device_class: moving
    filters:
      - delayed_on: 100ms
      - delayed_off: 500ms
  - platform: status
    name: "Home Assistant Verbonden?"
    icon: "mdi:wifi-check"
    disabled_by_default: true
sensor:
  - platform: custom
    lambda: |-
      auto my_custom_sensor = new UartReadRadarSensor(id(uart_bus));
      App.register_component(my_custom_sensor);
      return {my_custom_sensor->action_status, my_custom_sensor->movement_status };
    sensors:
      - name: ${display_name} Action
        id: office_presence_action
      - name: ${display_name} Movement
        id: office_presence_movement
        
    # Set human uptime (this is a readable version instead of seconds)
  - platform: uptime
    name: Uptime Sensor (raw)
    disabled_by_default: true
    id: uptime_sensor
    update_interval: 30s
    on_raw_value:
      then:
        - text_sensor.template.publish:
            id: uptime_human
            state: !lambda |-
              int seconds = round(id(uptime_sensor).raw_state);
              int days = seconds / (24 * 3600);
              seconds = seconds % (24 * 3600);
              int hours = seconds / 3600;
              seconds = seconds % 3600;
              int minutes = seconds /  60;
              seconds = seconds % 60;
              return (
                (days ? to_string(days) + "d " : "") +
                (hours ? to_string(hours) + "h " : "") +
                (minutes ? to_string(minutes) + "m " : "") +
                (to_string(seconds) + "s")
              ).c_str();

# Example configuration entry
text_sensor:
  - platform: template
    name: "${display_name} Action Description"
    id: office_presence_action_description
    lambda: |-
      if( id(office_presence_action).state == 2 ) {
        return{ "Movement" };
      }
      else if( id(office_presence_action).state == 3 ) {
        return{ "Stationary" };
      }
      else if( id(office_presence_action).state == 4 ) {
        return{ "No-movement" };
      }
      else if( id(office_presence_action).state == 5 ) {
        return{ "Closer" };
      }
      else if( id(office_presence_action).state == 6 ) {
        return{ "Further" };
      }
      return {"Vacant"};
    update_interval: ${update_time}
  - platform: template
    name: "${display_name} Movement Description"
    id: office_presence_movement_description
    lambda: |-
      if( id(office_presence_movement).state == 1 ) {
        return{ "Still" };
      }
      else if( id(office_presence_movement).state == 2 ) {
        return{ "Micro" };
      }
      else if( id(office_presence_movement).state == 3 ) {
        return{ "Slow" };
      }
      else if( id(office_presence_movement).state == 4 ) {
        return{ "Fast" };
      }
      return {"None"};
    update_interval: ${update_time}
    # Set WiFi info
  - platform: wifi_info
    ip_address:
      name: IPv4 adres
    ssid:
      name: "WiFi Netwerk"
      disabled_by_default: true
      
  # Set uptime
  - platform: template
    name: Uptime
    id: uptime_human
    icon: mdi:clock-start
    entity_category: diagnostic
    
  # Set ESPHome version
  - platform: version
    name: "ESPHome versie"
    hide_timestamp: true

    
button:
  - platform: restart
    id: restart_button
    name: "Herstart sensor"    